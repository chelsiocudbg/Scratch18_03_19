From 0461c2301a0966e59abcd347102c9d14acb86e38 Mon Sep 17 00:00:00 2001
From: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
Date: Tue, 7 Nov 2017 19:34:38 +0530
Subject: [PATCH 1/3] cxgb4: add cudbg support

Add support to collect cudbg debug logs from cxgb4.

Signed-off-by: Rahul Lakkireddy <rahul.lakkireddy@chelsio.com>
---
 drivers/net/ethernet/chelsio/cxgb4/Makefile        |   3 +-
 drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c  |  28 +-
 drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h      |   4 +
 drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c     | 251 +++++++++-------
 .../net/ethernet/chelsio/cxgb4/cudbg_lib_common.h  |  12 +-
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c   | 105 ++++++-
 drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h   |   3 +
 drivers/net/ethernet/chelsio/cxgb4/fastlz.c        | 328 +++++++++++++++++++++
 drivers/net/ethernet/chelsio/cxgb4/fastlz.h        |  88 ++++++
 drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c    | 176 +++++++++++
 drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h | 134 +++++++++
 11 files changed, 1016 insertions(+), 116 deletions(-)
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz.c
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz.h
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c
 create mode 100644 drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h

diff --git a/drivers/net/ethernet/chelsio/cxgb4/Makefile b/drivers/net/ethernet/chelsio/cxgb4/Makefile
index 5414a7de..121b6339 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/Makefile
+++ b/drivers/net/ethernet/chelsio/cxgb4/Makefile
@@ -6,7 +6,8 @@ obj-$(CONFIG_CHELSIO_T4) += cxgb4.o
 
 cxgb4-objs := cxgb4_main.o l2t.o t4_hw.o sge.o clip_tbl.o cxgb4_ethtool.o \
 	      cxgb4_cudbg.o \
-	      cudbg_common.o cudbg_lib.o
+	      cudbg_common.o cudbg_lib.o \
+	      fastlz_api.o fastlz.o
 cxgb4-$(CONFIG_CHELSIO_T4_DCB) +=  cxgb4_dcb.o
 cxgb4-$(CONFIG_CHELSIO_T4_UWIRE) +=  cxgb4_ppm.o
 cxgb4-$(CONFIG_DEBUG_FS) += cxgb4_debugfs.o
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c b/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c
index f78ba174..470dc1c8 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_common.c
@@ -18,8 +18,10 @@
 #include "cxgb4.h"
 #include "cudbg_if.h"
 #include "cudbg_lib_common.h"
+#include "fastlz_common.h"
 
-int cudbg_get_buff(struct cudbg_buffer *pdbg_buff, u32 size,
+int cudbg_get_buff(struct cudbg_init *pdbg_init,
+		   struct cudbg_buffer *pdbg_buff, u32 size,
 		   struct cudbg_buffer *pin_buff)
 {
 	u32 offset;
@@ -28,17 +30,37 @@ int cudbg_get_buff(struct cudbg_buffer *pdbg_buff, u32 size,
 	if (offset + size > pdbg_buff->size)
 		return CUDBG_STATUS_NO_MEM;
 
+	if (pdbg_init->compress_type != CUDBG_COMPRESSION_NONE) {
+		pin_buff->data = (char *)pdbg_init->compress_buff;
+		pin_buff->offset = 0;
+		pin_buff->size = size;
+		memset(pin_buff->data, 0, pin_buff->size);
+		return 0;
+	}
+
 	pin_buff->data = (char *)pdbg_buff->data + offset;
 	pin_buff->offset = offset;
 	pin_buff->size = size;
-	pdbg_buff->size -= size;
 	return 0;
 }
 
+void cudbg_get_compress_buff(struct cudbg_init *pdbg_init,
+			     struct cudbg_buffer *pdbg_buff,
+			     struct cudbg_buffer *pin_buff)
+{
+	/* There is at least CUDBG_BLOCK_SIZE extra reserved for
+	 * compression result during pdbg_init->compress_buff
+	 * allocation.  So, we can never run out of space.
+	 */
+	pin_buff->data = (char *)pdbg_init->compress_buff +
+			 pdbg_init->compress_buff_size;
+	pin_buff->offset = pdbg_init->compress_buff_size;
+	pin_buff->size = CUDBG_BLOCK_SIZE;
+}
+
 void cudbg_put_buff(struct cudbg_buffer *pin_buff,
 		    struct cudbg_buffer *pdbg_buff)
 {
-	pdbg_buff->size += pin_buff->size;
 	pin_buff->data = NULL;
 	pin_buff->offset = 0;
 	pin_buff->size = 0;
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h b/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h
index e8173ae3..941f71bb 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_if.h
@@ -86,6 +86,10 @@ struct cudbg_init {
 	struct adapter *adap; /* Pointer to adapter structure */
 	void *outbuf; /* Output buffer */
 	u32 outbuf_size;  /* Output buffer size */
+	u8 compress_type; /* Type of compression to use */
+	unsigned char *hash_table; /* Hash table used for fastlz compression */
+	void *compress_buff; /* Buffer used for compression */
+	u32 compress_buff_size; /* Compression buffer size */
 };
 
 static inline unsigned int cudbg_mbytes_to_bytes(unsigned int size)
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
index ed7244b6..1eab8c5c 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c
@@ -23,12 +23,59 @@
 #include "cudbg_lib_common.h"
 #include "cudbg_entity.h"
 #include "cudbg_lib.h"
+#include "fastlz_common.h"
 
-static void cudbg_write_and_release_buff(struct cudbg_buffer *pin_buff,
-					 struct cudbg_buffer *dbg_buff)
+static int cudbg_do_compression(struct cudbg_init *pdbg_init,
+				struct cudbg_buffer *pin_buff,
+				struct cudbg_buffer *dbg_buff)
 {
-	cudbg_update_buff(pin_buff, dbg_buff);
+	struct cudbg_buffer temp_in_buff = { 0 };
+	int bytes_left, bytes_read, bytes;
+	u32 offset = dbg_buff->offset;
+	int rc;
+
+	temp_in_buff.offset = pin_buff->offset;
+	temp_in_buff.data = pin_buff->data;
+	temp_in_buff.size = pin_buff->size;
+
+	bytes_left = pin_buff->size;
+	bytes_read = 0;
+	while (bytes_left > 0) {
+		bytes = min_t(unsigned long, bytes_left,
+			      (unsigned long)CUDBG_CHUNK_SIZE);
+		temp_in_buff.data = (char *)pin_buff->data + bytes_read;
+		temp_in_buff.size = bytes;
+		rc = cudbg_compress_buff(pdbg_init, &temp_in_buff, dbg_buff);
+		if (rc)
+			return rc;
+		bytes_left -= bytes;
+		bytes_read += bytes;
+	}
+
+	pin_buff->size = dbg_buff->offset - offset;
+	return 0;
+}
+
+static int cudbg_write_and_release_buff(struct cudbg_init *pdbg_init,
+					struct cudbg_buffer *pin_buff,
+					struct cudbg_buffer *dbg_buff)
+{
+	int rc = 0;
+
+	if (pdbg_init->compress_type == CUDBG_COMPRESSION_NONE) {
+		cudbg_update_buff(pin_buff, dbg_buff);
+	} else {
+		rc = cudbg_write_compression_hdr(pdbg_init, pin_buff, dbg_buff);
+		if (rc)
+			goto out;
+
+		rc = cudbg_do_compression(pdbg_init, pin_buff, dbg_buff);
+		if (rc)
+			goto out;
+	}
+out:
 	cudbg_put_buff(pin_buff, dbg_buff);
+	return rc;
 }
 
 static int is_fw_attached(struct cudbg_init *pdbg_init)
@@ -371,12 +418,11 @@ int cudbg_collect_reg_dump(struct cudbg_init *pdbg_init,
 	else if (is_t5(padap->params.chip) || is_t6(padap->params.chip))
 		buf_size = T5_REGMAP_SIZE;
 
-	rc = cudbg_get_buff(dbg_buff, buf_size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, buf_size, &temp_buff);
 	if (rc)
 		return rc;
 	t4_get_regs(padap, (void *)temp_buff.data, temp_buff.size);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_fw_devlog(struct cudbg_init *pdbg_init,
@@ -395,7 +441,7 @@ int cudbg_collect_fw_devlog(struct cudbg_init *pdbg_init,
 	}
 
 	dparams = &padap->params.devlog;
-	rc = cudbg_get_buff(dbg_buff, dparams->size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, dparams->size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -409,13 +455,12 @@ int cudbg_collect_fw_devlog(struct cudbg_init *pdbg_init,
 				  1);
 		spin_unlock(&padap->win0_lock);
 		if (rc) {
-			cudbg_err->sys_err = rc;
+			cudbg_err->sys_err = CUDBG_SYSTEM_ERROR;
 			cudbg_put_buff(&temp_buff, dbg_buff);
 			return rc;
 		}
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_la(struct cudbg_init *pdbg_init,
@@ -436,7 +481,7 @@ int cudbg_collect_cim_la(struct cudbg_init *pdbg_init,
 	}
 
 	size += sizeof(cfg);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -456,8 +501,7 @@ int cudbg_collect_cim_la(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_ma_la(struct cudbg_init *pdbg_init,
@@ -469,7 +513,7 @@ int cudbg_collect_cim_ma_la(struct cudbg_init *pdbg_init,
 	int size, rc;
 
 	size = 2 * CIM_MALA_SIZE * 5 * sizeof(u32);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -477,8 +521,7 @@ int cudbg_collect_cim_ma_la(struct cudbg_init *pdbg_init,
 			  (u32 *)temp_buff.data,
 			  (u32 *)((char *)temp_buff.data +
 				  5 * CIM_MALA_SIZE));
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_qcfg(struct cudbg_init *pdbg_init,
@@ -490,7 +533,7 @@ int cudbg_collect_cim_qcfg(struct cudbg_init *pdbg_init,
 	struct cudbg_cim_qcfg *cim_qcfg_data;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_cim_qcfg),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_cim_qcfg),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -516,8 +559,7 @@ int cudbg_collect_cim_qcfg(struct cudbg_init *pdbg_init,
 
 	t4_read_cimq_cfg(padap, cim_qcfg_data->base, cim_qcfg_data->size,
 			 cim_qcfg_data->thres);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static int cudbg_read_cim_ibq(struct cudbg_init *pdbg_init,
@@ -531,7 +573,7 @@ static int cudbg_read_cim_ibq(struct cudbg_init *pdbg_init,
 
 	/* collect CIM IBQ */
 	qsize = CIM_IBQ_SIZE * 4 * sizeof(u32);
-	rc = cudbg_get_buff(dbg_buff, qsize, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -548,8 +590,7 @@ static int cudbg_read_cim_ibq(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_ibq_tp0(struct cudbg_init *pdbg_init,
@@ -616,7 +657,7 @@ static int cudbg_read_cim_obq(struct cudbg_init *pdbg_init,
 
 	/* collect CIM OBQ */
 	qsize =  cudbg_cim_obq_size(padap, qid);
-	rc = cudbg_get_buff(dbg_buff, qsize, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, qsize, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -633,8 +674,7 @@ static int cudbg_read_cim_obq(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_obq_ulp0(struct cudbg_init *pdbg_init,
@@ -874,6 +914,14 @@ static int cudbg_read_fw_mem(struct cudbg_init *pdbg_init,
 		}
 	}
 
+	if (pdbg_init->compress_type != CUDBG_COMPRESSION_NONE) {
+		temp_buff.size = tot_len;
+		rc = cudbg_write_compression_hdr(pdbg_init, &temp_buff,
+						 dbg_buff);
+		if (rc)
+			return rc;
+	}
+
 	bytes_left = tot_len;
 	while (bytes_left > 0) {
 		/* As MC size is huge and read through PIO access, this
@@ -887,7 +935,7 @@ static int cudbg_read_fw_mem(struct cudbg_init *pdbg_init,
 
 		bytes = min_t(unsigned long, bytes_left,
 			      (unsigned long)CUDBG_CHUNK_SIZE);
-		rc = cudbg_get_buff(dbg_buff, bytes, &temp_buff);
+		rc = cudbg_get_buff(pdbg_init, dbg_buff, bytes, &temp_buff);
 		if (rc)
 			return rc;
 
@@ -913,7 +961,18 @@ static int cudbg_read_fw_mem(struct cudbg_init *pdbg_init,
 skip_read:
 		bytes_left -= bytes;
 		bytes_read += bytes;
-		cudbg_write_and_release_buff(&temp_buff, dbg_buff);
+		if (pdbg_init->compress_type == CUDBG_COMPRESSION_NONE) {
+			cudbg_update_buff(&temp_buff, dbg_buff);
+		} else {
+			rc = cudbg_do_compression(pdbg_init, &temp_buff,
+						  dbg_buff);
+			if (rc) {
+				cudbg_err->sys_err = rc;
+				cudbg_put_buff(&temp_buff, dbg_buff);
+				return rc;
+			}
+		}
+		cudbg_put_buff(&temp_buff, dbg_buff);
 	}
 	return rc;
 }
@@ -1007,7 +1066,8 @@ int cudbg_collect_rss(struct cudbg_init *pdbg_init,
 	int rc, nentries;
 
 	nentries = t4_chip_rss_size(padap);
-	rc = cudbg_get_buff(dbg_buff, nentries * sizeof(u16), &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, nentries * sizeof(u16),
+			    &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1017,8 +1077,7 @@ int cudbg_collect_rss(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_rss_vf_config(struct cudbg_init *pdbg_init,
@@ -1031,7 +1090,7 @@ int cudbg_collect_rss_vf_config(struct cudbg_init *pdbg_init,
 	int vf, rc, vf_count;
 
 	vf_count = padap->params.arch.vfcount;
-	rc = cudbg_get_buff(dbg_buff,
+	rc = cudbg_get_buff(pdbg_init, dbg_buff,
 			    vf_count * sizeof(struct cudbg_rss_vf_conf),
 			    &temp_buff);
 	if (rc)
@@ -1041,8 +1100,7 @@ int cudbg_collect_rss_vf_config(struct cudbg_init *pdbg_init,
 	for (vf = 0; vf < vf_count; vf++)
 		t4_read_rss_vf_config(padap, vf, &vfconf[vf].rss_vf_vfl,
 				      &vfconf[vf].rss_vf_vfh, true);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_path_mtu(struct cudbg_init *pdbg_init,
@@ -1053,13 +1111,12 @@ int cudbg_collect_path_mtu(struct cudbg_init *pdbg_init,
 	struct cudbg_buffer temp_buff = { 0 };
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, NMTUS * sizeof(u16), &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, NMTUS * sizeof(u16), &temp_buff);
 	if (rc)
 		return rc;
 
 	t4_read_mtu_tbl(padap, (u16 *)temp_buff.data, NULL);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pm_stats(struct cudbg_init *pdbg_init,
@@ -1071,7 +1128,7 @@ int cudbg_collect_pm_stats(struct cudbg_init *pdbg_init,
 	struct cudbg_pm_stats *pm_stats_buff;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_pm_stats),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_pm_stats),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1079,8 +1136,7 @@ int cudbg_collect_pm_stats(struct cudbg_init *pdbg_init,
 	pm_stats_buff = (struct cudbg_pm_stats *)temp_buff.data;
 	t4_pmtx_get_stats(padap, pm_stats_buff->tx_cnt, pm_stats_buff->tx_cyc);
 	t4_pmrx_get_stats(padap, pm_stats_buff->rx_cnt, pm_stats_buff->rx_cyc);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,
@@ -1095,7 +1151,7 @@ int cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,
 	if (!padap->params.vpd.cclk)
 		return CUDBG_STATUS_CCLK_NOT_DEFINED;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_hw_sched),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_hw_sched),
 			    &temp_buff);
 	hw_sched_buff = (struct cudbg_hw_sched *)temp_buff.data;
 	hw_sched_buff->map = t4_read_reg(padap, TP_TX_MOD_QUEUE_REQ_MAP_A);
@@ -1104,8 +1160,7 @@ int cudbg_collect_hw_sched(struct cudbg_init *pdbg_init,
 	for (i = 0; i < NTX_SCHED; ++i)
 		t4_get_tx_sched(padap, i, &hw_sched_buff->kbps[i],
 				&hw_sched_buff->ipg[i], true);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_tp_indirect(struct cudbg_init *pdbg_init,
@@ -1129,7 +1184,7 @@ int cudbg_collect_tp_indirect(struct cudbg_init *pdbg_init,
 
 	n = n / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1218,8 +1273,7 @@ int cudbg_collect_tp_indirect(struct cudbg_init *pdbg_init,
 			       tp_pio->ireg_local_offset, true);
 		ch_tp_pio++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_sge_indirect(struct cudbg_init *pdbg_init,
@@ -1231,7 +1285,7 @@ int cudbg_collect_sge_indirect(struct cudbg_init *pdbg_init,
 	struct ireg_buf *ch_sge_dbg;
 	int i, rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(*ch_sge_dbg) * 2, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(*ch_sge_dbg) * 2, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1252,8 +1306,7 @@ int cudbg_collect_sge_indirect(struct cudbg_init *pdbg_init,
 				 sge_pio->ireg_local_offset);
 		ch_sge_dbg++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_ulprx_la(struct cudbg_init *pdbg_init,
@@ -1265,7 +1318,7 @@ int cudbg_collect_ulprx_la(struct cudbg_init *pdbg_init,
 	struct cudbg_ulprx_la *ulprx_la_buff;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_ulprx_la),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_ulprx_la),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1273,8 +1326,7 @@ int cudbg_collect_ulprx_la(struct cudbg_init *pdbg_init,
 	ulprx_la_buff = (struct cudbg_ulprx_la *)temp_buff.data;
 	t4_ulprx_read_la(padap, (u32 *)ulprx_la_buff->data);
 	ulprx_la_buff->size = ULPRX_LA_SIZE;
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_tp_la(struct cudbg_init *pdbg_init,
@@ -1287,15 +1339,14 @@ int cudbg_collect_tp_la(struct cudbg_init *pdbg_init,
 	int size, rc;
 
 	size = sizeof(struct cudbg_tp_la) + TPLA_SIZE *  sizeof(u64);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
 	tp_la_buff = (struct cudbg_tp_la *)temp_buff.data;
 	tp_la_buff->mode = DBGLAMODE_G(t4_read_reg(padap, TP_DBG_LA_CONFIG_A));
 	t4_tp_read_la(padap, (u64 *)tp_la_buff->data, NULL);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_meminfo(struct cudbg_init *pdbg_init,
@@ -1307,7 +1358,7 @@ int cudbg_collect_meminfo(struct cudbg_init *pdbg_init,
 	struct cudbg_meminfo *meminfo_buff;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_meminfo), &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_meminfo), &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1319,8 +1370,7 @@ int cudbg_collect_meminfo(struct cudbg_init *pdbg_init,
 		return rc;
 	}
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cim_pif_la(struct cudbg_init *pdbg_init,
@@ -1334,7 +1384,7 @@ int cudbg_collect_cim_pif_la(struct cudbg_init *pdbg_init,
 
 	size = sizeof(struct cudbg_cim_pif_la) +
 	       2 * CIM_PIFLA_SIZE * 6 * sizeof(u32);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1343,8 +1393,7 @@ int cudbg_collect_cim_pif_la(struct cudbg_init *pdbg_init,
 	t4_cim_read_pif_la(padap, (u32 *)cim_pif_la_buff->data,
 			   (u32 *)cim_pif_la_buff->data + 6 * CIM_PIFLA_SIZE,
 			   NULL, NULL);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_clk_info(struct cudbg_init *pdbg_init,
@@ -1360,7 +1409,7 @@ int cudbg_collect_clk_info(struct cudbg_init *pdbg_init,
 	if (!padap->params.vpd.cclk)
 		return CUDBG_STATUS_CCLK_NOT_DEFINED;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_clk_info),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_clk_info),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1392,8 +1441,7 @@ int cudbg_collect_clk_info(struct cudbg_init *pdbg_init,
 	clk_info_buff->finwait2_timer =
 		tp_tick_us * t4_read_reg(padap, TP_FINWAIT2_TIMER_A);
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pcie_indirect(struct cudbg_init *pdbg_init,
@@ -1408,7 +1456,7 @@ int cudbg_collect_pcie_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t5_pcie_pdbg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n * 2;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1449,8 +1497,7 @@ int cudbg_collect_pcie_indirect(struct cudbg_init *pdbg_init,
 				 pcie_pio->ireg_local_offset);
 		ch_pcie++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pm_indirect(struct cudbg_init *pdbg_init,
@@ -1465,7 +1512,7 @@ int cudbg_collect_pm_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t5_pm_rx_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n * 2;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1506,8 +1553,7 @@ int cudbg_collect_pm_indirect(struct cudbg_init *pdbg_init,
 				 pm_pio->ireg_local_offset);
 		ch_pm++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_tid(struct cudbg_init *pdbg_init,
@@ -1521,7 +1567,7 @@ int cudbg_collect_tid(struct cudbg_init *pdbg_init,
 	u32 para[2], val[2];
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_tid_info_region_rev1),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_tid_info_region_rev1),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -1591,8 +1637,7 @@ int cudbg_collect_tid(struct cudbg_init *pdbg_init,
 
 #undef FW_PARAM_PFVF_A
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pcie_config(struct cudbg_init *pdbg_init,
@@ -1606,7 +1651,7 @@ int cudbg_collect_pcie_config(struct cudbg_init *pdbg_init,
 
 	size = sizeof(u32) * CUDBG_NUM_PCIE_CONFIG_REGS;
 	n = sizeof(t5_pcie_config_array) / (2 * sizeof(u32));
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1618,8 +1663,7 @@ int cudbg_collect_pcie_config(struct cudbg_init *pdbg_init,
 			value++;
 		}
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static int cudbg_sge_ctxt_check_valid(u32 *buf, int type)
@@ -1799,7 +1843,7 @@ int cudbg_collect_dump_context(struct cudbg_init *pdbg_init,
 		return CUDBG_STATUS_ENTITY_NOT_FOUND;
 
 	size = rc;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -1876,8 +1920,7 @@ int cudbg_collect_dump_context(struct cudbg_init *pdbg_init,
 	 */
 	cudbg_get_sge_ctxt_fw(pdbg_init, max_ctx_qid, CTXT_FLM, &buff);
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static inline void cudbg_tcamxy2valmask(u64 x, u64 y, u8 *addr, u64 *mask)
@@ -2038,7 +2081,7 @@ int cudbg_collect_mps_tcam(struct cudbg_init *pdbg_init,
 
 	n = padap->params.arch.mps_tcam_size;
 	size = sizeof(struct cudbg_mps_tcam) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2060,8 +2103,7 @@ int cudbg_collect_mps_tcam(struct cudbg_init *pdbg_init,
 		cudbg_put_buff(&temp_buff, dbg_buff);
 		return rc;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,
@@ -2077,7 +2119,7 @@ int cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,
 	int rc, ret;
 
 	rc = t4_get_raw_vpd_params(padap, &vpd);
-	if (rc)
+	if (rc < 0)
 		return rc;
 
 	rc = t4_get_fw_version(padap, &fw_vers);
@@ -2112,7 +2154,7 @@ int cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,
 	if (rc)
 		return rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_vpd_data),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_vpd_data),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -2128,8 +2170,7 @@ int cudbg_collect_vpd_data(struct cudbg_init *pdbg_init,
 	vpd_data->fw_minor = FW_HDR_FW_VER_MINOR_G(fw_vers);
 	vpd_data->fw_micro = FW_HDR_FW_VER_MICRO_G(fw_vers);
 	vpd_data->fw_build = FW_HDR_FW_VER_BUILD_G(fw_vers);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 static int cudbg_read_tid(struct cudbg_init *pdbg_init, u32 tid,
@@ -2280,7 +2321,7 @@ int cudbg_collect_le_tcam(struct cudbg_init *pdbg_init,
 
 	size = sizeof(struct cudbg_tid_data) * tcam_region.max_tid;
 	size += sizeof(struct cudbg_tcam);
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2303,8 +2344,7 @@ int cudbg_collect_le_tcam(struct cudbg_init *pdbg_init,
 		bytes += sizeof(struct cudbg_tid_data);
 	}
 
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_cctrl(struct cudbg_init *pdbg_init,
@@ -2317,13 +2357,12 @@ int cudbg_collect_cctrl(struct cudbg_init *pdbg_init,
 	int rc;
 
 	size = sizeof(u16) * NMTUS * NCCTRL_WIN;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
 	t4_read_cong_tbl(padap, (void *)temp_buff.data);
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_ma_indirect(struct cudbg_init *pdbg_init,
@@ -2341,7 +2380,7 @@ int cudbg_collect_ma_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t6_ma_ireg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n * 2;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2377,8 +2416,7 @@ int cudbg_collect_ma_indirect(struct cudbg_init *pdbg_init,
 		}
 		ma_indr++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_ulptx_la(struct cudbg_init *pdbg_init,
@@ -2391,7 +2429,7 @@ int cudbg_collect_ulptx_la(struct cudbg_init *pdbg_init,
 	u32 i, j;
 	int rc;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_ulptx_la),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_ulptx_la),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -2412,8 +2450,7 @@ int cudbg_collect_ulptx_la(struct cudbg_init *pdbg_init,
 				t4_read_reg(padap,
 					    ULP_TX_LA_RDDATA_0_A + 0x10 * i);
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_up_cim_indirect(struct cudbg_init *pdbg_init,
@@ -2428,7 +2465,7 @@ int cudbg_collect_up_cim_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t5_up_cim_reg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2461,8 +2498,7 @@ int cudbg_collect_up_cim_indirect(struct cudbg_init *pdbg_init,
 		}
 		up_cim++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_pbt_tables(struct cudbg_init *pdbg_init,
@@ -2475,7 +2511,7 @@ int cudbg_collect_pbt_tables(struct cudbg_init *pdbg_init,
 	int i, rc;
 	u32 addr;
 
-	rc = cudbg_get_buff(dbg_buff, sizeof(struct cudbg_pbt_tables),
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, sizeof(struct cudbg_pbt_tables),
 			    &temp_buff);
 	if (rc)
 		return rc;
@@ -2529,8 +2565,7 @@ int cudbg_collect_pbt_tables(struct cudbg_init *pdbg_init,
 			return rc;
 		}
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_mbox_log(struct cudbg_init *pdbg_init,
@@ -2551,7 +2586,7 @@ int cudbg_collect_mbox_log(struct cudbg_init *pdbg_init,
 	log = padap->mbox_log;
 	mbox_cmds = padap->mbox_log->size;
 	size = sizeof(struct cudbg_mbox_log) * mbox_cmds;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2574,8 +2609,7 @@ int cudbg_collect_mbox_log(struct cudbg_init *pdbg_init,
 		}
 		mboxlog++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
 
 int cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,
@@ -2593,7 +2627,7 @@ int cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,
 
 	n = sizeof(t6_hma_ireg_array) / (IREG_NUM_ELEM * sizeof(u32));
 	size = sizeof(struct ireg_buf) * n;
-	rc = cudbg_get_buff(dbg_buff, size, &temp_buff);
+	rc = cudbg_get_buff(pdbg_init, dbg_buff, size, &temp_buff);
 	if (rc)
 		return rc;
 
@@ -2611,6 +2645,5 @@ int cudbg_collect_hma_indirect(struct cudbg_init *pdbg_init,
 				 hma_fli->ireg_local_offset);
 		hma_indr++;
 	}
-	cudbg_write_and_release_buff(&temp_buff, dbg_buff);
-	return rc;
+	return cudbg_write_and_release_buff(pdbg_init, &temp_buff, dbg_buff);
 }
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h
index 24b33f28..9c31885d 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib_common.h
@@ -78,10 +78,20 @@ struct cudbg_error {
 #define CDUMP_MAX_COMP_BUF_SIZE ((64 * 1024) - 1)
 #define CUDBG_CHUNK_SIZE ((CDUMP_MAX_COMP_BUF_SIZE / 1024) * 1024)
 
-int cudbg_get_buff(struct cudbg_buffer *pdbg_buff, u32 size,
+int cudbg_get_buff(struct cudbg_init *pdbg_init,
+		   struct cudbg_buffer *pdbg_buff, u32 size,
 		   struct cudbg_buffer *pin_buff);
+void cudbg_get_compress_buff(struct cudbg_init *pdbg_init,
+			     struct cudbg_buffer *pdbg_buff,
+			     struct cudbg_buffer *pin_buff);
 void cudbg_put_buff(struct cudbg_buffer *pin_buff,
 		    struct cudbg_buffer *pdbg_buff);
 void cudbg_update_buff(struct cudbg_buffer *pin_buff,
 		       struct cudbg_buffer *pout_buff);
+int cudbg_write_compression_hdr(struct cudbg_init *pdbg_init,
+				struct cudbg_buffer *pin_buff,
+				struct cudbg_buffer *pout_buff);
+int cudbg_compress_buff(struct cudbg_init *pdbg_init,
+			struct cudbg_buffer *pin_buff,
+			struct cudbg_buffer *pout_buff);
 #endif /* __CUDBG_LIB_COMMON_H__ */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c
index 581d628f..591b7d94 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c
@@ -18,6 +18,7 @@
 #include "t4_regs.h"
 #include "cxgb4.h"
 #include "cxgb4_cudbg.h"
+#include "fastlz_common.h"
 
 static const struct cxgb4_collect_entity cxgb4_collect_mem_dump[] = {
 	{ CUDBG_EDC0, cudbg_collect_edc0_meminfo },
@@ -76,6 +77,22 @@ static const struct cxgb4_collect_entity cxgb4_collect_hw_dump[] = {
 	{ CUDBG_HMA_INDIRECT, cudbg_collect_hma_indirect },
 };
 
+static const char * cxgb4_entity_string[] = {
+	"all", "regdump", "devlog", "cimla", "cimmala", "cimqcfg",
+	"ibqtp0", "ibqtp1", "ibqulp", "ibqsge0", "ibqsge1", "ibqncsi",
+	"obqulp0", "obqulp1", "obqulp2", "obqulp3", "obqsge", "obqncsi",
+	"edc0", "edc1", "mc0", "mc1", "rss", "rss_pf_config", "rss_key",
+	"rss_vf_config", "rss_config", "pathmtu", "swstate", "wtp", "pmstats",
+	"hwsched", "tcpstats", "tperrstats", "fcoestats", "rdmastats",
+	"tpindirect", "sgeindirect", "cplstats", "ddpstats", "wcstats",
+	"ulprxla", "lbstats", "tpla", "meminfo", "cimpifla", "clk",
+	"obq_sge_rx_q0", "obq_sge_rx_q1", "macstats", "pcieindirect",
+	"pmindirect", "full", "txrate", "tidinfo", "pcieconfig",
+	"dumpcontext", "mpstcam", "vpddata", "letcam", "cctrl", "maindirect",
+	"ulptxla", "extentity", "upcimindirect", "pbttables",
+	"mboxlog", "hmaindirect", "hma", "upload",
+};
+
 static u32 cxgb4_get_entity_length(struct adapter *adap, u32 entity)
 {
 	struct cudbg_tcam tcam_region = { 0 };
@@ -338,23 +355,30 @@ static void cxgb4_cudbg_collect_entity(struct cudbg_init *pdbg_init,
 	struct adapter *adap = pdbg_init->adap;
 	struct cudbg_error cudbg_err = { 0 };
 	struct cudbg_entity_hdr *entity_hdr;
+	struct cudbg_hdr *cudbg_hdr;
 	u32 entity_size, i;
 	u32 total_size = 0;
 	int ret;
 
+	cudbg_hdr = pdbg_init->outbuf;
 	for (i = 0; i < arr_size; i++) {
 		const struct cxgb4_collect_entity *e = &e_arr[i];
 
 		/* Skip entities that won't fit in output buffer */
 		entity_size = cxgb4_get_entity_length(adap, e->entity);
 		if (entity_size >
-		    pdbg_init->outbuf_size - *tot_size - total_size)
+		    pdbg_init->outbuf_size - *tot_size - total_size) {
+			dev_warn(adap->pdev_dev, "No space for entity %s, Skipping",
+				 cxgb4_entity_string[e->entity]);
 			continue;
+		}
 
 		entity_hdr = cudbg_get_entity_hdr(buf, e->entity);
 		entity_hdr->entity_type = e->entity;
 		entity_hdr->start_offset = dbg_buff->offset;
 		memset(&cudbg_err, 0, sizeof(struct cudbg_error));
+		dev_info(adap->pdev_dev, "Collecting debug entity %s",
+			 cxgb4_entity_string[e->entity]);
 		ret = e->collect_cb(pdbg_init, dbg_buff, &cudbg_err);
 		if (ret) {
 			entity_hdr->size = 0;
@@ -363,6 +387,11 @@ static void cxgb4_cudbg_collect_entity(struct cudbg_init *pdbg_init,
 			cudbg_align_debug_buffer(dbg_buff, entity_hdr);
 		}
 
+		if (ret)
+			dev_warn(adap->pdev_dev, "status: %d", ret);
+		else
+			dev_info(adap->pdev_dev, "size: %u", entity_hdr->size);
+
 		/* Log error and continue with next entity */
 		if (cudbg_err.sys_err)
 			ret = CUDBG_SYSTEM_ERROR;
@@ -371,6 +400,7 @@ static void cxgb4_cudbg_collect_entity(struct cudbg_init *pdbg_init,
 		entity_hdr->sys_err = cudbg_err.sys_err;
 		entity_hdr->sys_warn = cudbg_err.sys_warn;
 		total_size += entity_hdr->size;
+		cudbg_hdr->data_len += entity_hdr->size;
 	}
 
 	*tot_size += total_size;
@@ -403,6 +433,7 @@ int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 	cudbg_hdr->chip_ver = adap->params.chip;
 	cudbg_hdr->dump_type = CUDBG_DUMP_TYPE_MINI;
 	cudbg_hdr->compress_type = CUDBG_COMPRESSION_NONE;
+	cudbg_init.compress_type = CUDBG_COMPRESSION_NONE;
 
 	min_size = sizeof(struct cudbg_hdr) +
 		   sizeof(struct cudbg_entity_hdr) *
@@ -412,6 +443,7 @@ int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 
 	dbg_buff.offset += min_size;
 	total_size = dbg_buff.offset;
+	cudbg_hdr->data_len = total_size;
 
 	if (flag & CXGB4_ETH_DUMP_HW)
 		cxgb4_cudbg_collect_entity(&cudbg_init, &dbg_buff,
@@ -427,7 +459,6 @@ int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 					   buf,
 					   &total_size);
 
-	cudbg_hdr->data_len = total_size;
 	*buf_size = total_size;
 	return 0;
 }
@@ -438,3 +469,73 @@ void cxgb4_init_ethtool_dump(struct adapter *adapter)
 	adapter->eth_dump.version = adapter->params.fw_vers;
 	adapter->eth_dump.len = 0;
 }
+
+int cxgb4_cudbg_collect_panic(struct adapter *adap, void *buf, u32 buf_size)
+{
+	struct cudbg_init cudbg_init = { 0 };
+	struct cudbg_buffer dbg_buff = { 0 };
+	u32 size, min_size, total_size = 0;
+	struct cudbg_hdr *cudbg_hdr;
+
+	size = buf_size;
+
+	cudbg_init.adap = adap;
+	cudbg_init.outbuf = buf;
+	cudbg_init.outbuf_size = size;
+	cudbg_init.hash_table = t4_alloc_mem(sizeof(unsigned char *) *
+					     FASTLZ_HASH_SIZE);
+	if (!cudbg_init.hash_table)
+		return -ENOMEM;
+
+	/* Give extra CUDBG_BLOCK_SIZE for storing compression result */
+	cudbg_init.compress_buff = t4_alloc_mem(CUDBG_COMPRESS_BUFF_SIZE +
+						CUDBG_BLOCK_SIZE);
+	if (!cudbg_init.compress_buff)
+		goto free_mem;
+
+	cudbg_init.compress_buff_size = CUDBG_COMPRESS_BUFF_SIZE;
+
+	dbg_buff.data = buf;
+	dbg_buff.size = size;
+	dbg_buff.offset = 0;
+
+	cudbg_hdr = (struct cudbg_hdr *)buf;
+	cudbg_hdr->signature = CUDBG_SIGNATURE;
+	cudbg_hdr->hdr_len = sizeof(struct cudbg_hdr);
+	cudbg_hdr->major_ver = CUDBG_MAJOR_VERSION;
+	cudbg_hdr->minor_ver = CUDBG_MINOR_VERSION;
+	cudbg_hdr->max_entities = CUDBG_MAX_ENTITY;
+	cudbg_hdr->chip_ver = adap->params.chip;
+
+	min_size = sizeof(struct cudbg_hdr) +
+		   sizeof(struct cudbg_entity_hdr) *
+		   cudbg_hdr->max_entities;
+	if (size < min_size) {
+		dev_info(adap->pdev_dev, "FAIL - Min buf size: %u required\n",
+			 min_size);
+		goto free_mem;
+	}
+
+	dbg_buff.offset += min_size;
+	total_size = dbg_buff.offset;
+	cudbg_hdr->data_len = total_size;
+
+	cxgb4_cudbg_collect_entity(&cudbg_init, &dbg_buff,
+				   cxgb4_collect_hw_dump,
+				   ARRAY_SIZE(cxgb4_collect_hw_dump),
+				   buf,
+				   &total_size);
+
+	cxgb4_cudbg_collect_entity(&cudbg_init, &dbg_buff,
+				   cxgb4_collect_mem_dump,
+				   ARRAY_SIZE(cxgb4_collect_mem_dump),
+				   buf,
+				   &total_size);
+
+free_mem:
+	if (cudbg_init.compress_buff)
+		t4_free_mem(cudbg_init.compress_buff);
+	if (cudbg_init.hash_table)
+		t4_free_mem(cudbg_init.hash_table);
+	return 0;
+}
diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h
index 7ceeb0bc..729e2546 100644
--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h
+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.h
@@ -23,6 +23,8 @@
 #include "cudbg_entity.h"
 #include "cudbg_lib.h"
 
+#define CUDBG_COMPRESS_BUFF_SIZE (4 * 1024 * 1024) /* 4MB */
+
 typedef int (*cudbg_collect_callback_t)(struct cudbg_init *pdbg_init,
 					struct cudbg_buffer *dbg_buff,
 					struct cudbg_error *cudbg_err);
@@ -41,5 +43,6 @@ enum CXGB4_ETHTOOL_DUMP_FLAGS {
 u32 cxgb4_get_dump_length(struct adapter *adap, u32 flag);
 int cxgb4_cudbg_collect(struct adapter *adap, void *buf, u32 *buf_size,
 			u32 flag);
+int cxgb4_cudbg_collect_panic(struct adapter *adap, void *buf, u32 buf_size);
 void cxgb4_init_ethtool_dump(struct adapter *adapter);
 #endif /* __CXGB4_CUDBG_H__ */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz.c b/drivers/net/ethernet/chelsio/cxgb4/fastlz.c
new file mode 100644
index 00000000..331d1ff1
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz.c
@@ -0,0 +1,328 @@
+/*
+   FastLZ - lightning-fast lossless compression library
+
+   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2017 Chelsio Communications
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+   */
+
+#include "fastlz_common.h"
+
+#if !defined(FASTLZ_COMPRESSOR)
+
+#undef FASTLZ_LEVEL
+#define FASTLZ_LEVEL 1
+
+#undef FASTLZ_COMPRESSOR
+#define FASTLZ_COMPRESSOR fastlz1_compress
+static FASTLZ_INLINE int FASTLZ_COMPRESSOR(unsigned char *hash_table,
+					   const void *input, int length,
+					   void *output);
+#include "fastlz.c"
+
+#undef FASTLZ_LEVEL
+#define FASTLZ_LEVEL 2
+
+#undef MAX_DISTANCE
+#define MAX_DISTANCE 8191
+#define MAX_FARDISTANCE (65535 + MAX_DISTANCE - 1)
+
+#undef FASTLZ_COMPRESSOR
+#define FASTLZ_COMPRESSOR fastlz2_compress
+static FASTLZ_INLINE int FASTLZ_COMPRESSOR(unsigned char *hash_table,
+					   const void *input, int length,
+					   void *output);
+#include "fastlz.c"
+
+int fastlz_compress(unsigned char *hash_table, const void *input, int length,
+		    void *output)
+{
+	/* for short block, choose fastlz1 */
+	if (length < 65536)
+		return fastlz1_compress(hash_table, input, length, output);
+
+	/* else... */
+	return fastlz2_compress(hash_table, input, length, output);
+}
+
+int fastlz_compress_level(unsigned char *hash_table, int level,
+			  const void *input, int length,
+			  void *output)
+{
+	if (level == 1)
+		return fastlz1_compress(hash_table, input, length, output);
+	if (level == 2)
+		return fastlz2_compress(hash_table, input, length, output);
+
+	return 0;
+}
+
+#else /* !defined(FASTLZ_COMPRESSOR) */
+
+static FASTLZ_INLINE int FASTLZ_COMPRESSOR(unsigned char *hash_table,
+					   const void *input, int length,
+					   void *output)
+{
+	const unsigned char *ip = (const unsigned char *) input;
+	const unsigned char *ip_bound = ip + length - 2;
+	const unsigned char *ip_limit = ip + length - 12;
+	unsigned char *op = (unsigned char *) output;
+
+	const unsigned char **htab = (const unsigned char **)hash_table;
+	const unsigned char **hslot;
+	unsigned int hval;
+
+	unsigned int copy;
+
+	/* sanity check */
+	if (FASTLZ_UNEXPECT_CONDITIONAL(length < 4)) {
+		if (length) {
+			/* create literal copy only */
+			*op++ = length - 1;
+			ip_bound++;
+			while (ip <= ip_bound)
+				*op++ = *ip++;
+			return length + 1;
+		} else
+			return 0;
+	}
+
+	/* initializes hash table */
+	for (hslot = htab; hslot < htab + FASTLZ_HASH_SIZE; hslot++)
+		*hslot = ip;
+
+	/* we start with literal copy */
+	copy = 2;
+	*op++ = MAX_COPY - 1;
+	*op++ = *ip++;
+	*op++ = *ip++;
+
+	/* main loop */
+	while (FASTLZ_EXPECT_CONDITIONAL(ip < ip_limit)) {
+		const unsigned char *ref;
+		unsigned int distance;
+
+		/* minimum match length */
+		unsigned int len = 3;
+
+		/* comparison starting-point */
+		const unsigned char *anchor = ip;
+
+		/* check for a run */
+#if FASTLZ_LEVEL == 2
+		if (ip[0] == ip[-1] &&
+		    FASTLZ_READU16(ip - 1) == FASTLZ_READU16(ip + 1)) {
+			distance = 1;
+			ip += 3;
+			ref = anchor - 1 + 3;
+			goto match;
+		}
+#endif
+
+		/* find potential match */
+		HASH_FUNCTION(hval, ip);
+		hslot = htab + hval;
+		ref = htab[hval];
+
+		/* calculate distance to the match */
+		distance = anchor - ref;
+
+		/* update hash table */
+		*hslot = anchor;
+
+		if (!ref)
+			goto literal;
+		/* is this a match? check the first 3 bytes */
+		if (distance == 0 ||
+#if FASTLZ_LEVEL == 1
+				(distance >= MAX_DISTANCE) ||
+#else
+				(distance >= MAX_FARDISTANCE) ||
+#endif
+				*ref++ != *ip++ || *ref++ != *ip++ ||
+				*ref++ != *ip++)
+			goto literal;
+
+#if FASTLZ_LEVEL == 2
+		/* far, needs at least 5-byte match */
+		if (distance >= MAX_DISTANCE) {
+			if (*ip++ != *ref++ || *ip++ != *ref++)
+				goto literal;
+			len += 2;
+		}
+
+match:
+#endif
+
+		/* last matched byte */
+		ip = anchor + len;
+
+		/* distance is biased */
+		distance--;
+
+		if (!distance) {
+			/* zero distance means a run */
+			unsigned char x = ip[-1];
+			while (ip < ip_bound)
+				if (*ref++ != x)
+					break;
+				else
+					ip++;
+		} else
+			for (;;) {
+				/* safe because the outer check
+				 * against ip limit */
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				if (*ref++ != *ip++)
+					break;
+				while (ip < ip_bound)
+					if (*ref++ != *ip++)
+						break;
+				break;
+			}
+
+		/* if we have copied something, adjust the copy count */
+		if (copy)
+			/* copy is biased, '0' means 1 byte copy */
+			*(op - copy - 1) = copy - 1;
+		else
+			/* back, to overwrite the copy count */
+			op--;
+
+		/* reset literal counter */
+		copy = 0;
+
+		/* length is biased, '1' means a match of 3 bytes */
+		ip -= 3;
+		len = ip - anchor;
+
+		/* encode the match */
+#if FASTLZ_LEVEL == 2
+		if (distance < MAX_DISTANCE) {
+			if (len < 7) {
+				*op++ = (len << 5) + (distance >> 8);
+				*op++ = (distance & 255);
+			} else {
+				*op++ = (7 << 5) + (distance >> 8);
+				for (len -= 7; len >= 255; len -= 255)
+					*op++ = 255;
+				*op++ = len;
+				*op++ = (distance & 255);
+			}
+		} else {
+			/* far away, but not yet in the another galaxy... */
+			if (len < 7) {
+				distance -= MAX_DISTANCE;
+				*op++ = (len << 5) + 31;
+				*op++ = 255;
+				*op++ = distance >> 8;
+				*op++ = distance & 255;
+			} else {
+				distance -= MAX_DISTANCE;
+				*op++ = (7 << 5) + 31;
+				for (len -= 7; len >= 255; len -= 255)
+					*op++ = 255;
+				*op++ = len;
+				*op++ = 255;
+				*op++ = distance >> 8;
+				*op++ = distance & 255;
+			}
+		}
+#else
+
+		if (FASTLZ_UNEXPECT_CONDITIONAL(len > MAX_LEN - 2))
+			while (len > MAX_LEN - 2) {
+				*op++ = (7 << 5) + (distance >> 8);
+				*op++ = MAX_LEN - 2 - 7 - 2;
+				*op++ = (distance & 255);
+				len -= MAX_LEN - 2;
+			}
+
+		if (len < 7) {
+			*op++ = (len << 5) + (distance >> 8);
+			*op++ = (distance & 255);
+		} else {
+			*op++ = (7 << 5) + (distance >> 8);
+			*op++ = len - 7;
+			*op++ = (distance & 255);
+		}
+#endif
+
+		/* update the hash at match boundary */
+		HASH_FUNCTION(hval, ip);
+		htab[hval] = ip++;
+		HASH_FUNCTION(hval, ip);
+		htab[hval] = ip++;
+
+		/* assuming literal copy */
+		*op++ = MAX_COPY - 1;
+
+		continue;
+
+literal:
+		*op++ = *anchor++;
+		ip = anchor;
+		copy++;
+		if (FASTLZ_UNEXPECT_CONDITIONAL(copy == MAX_COPY)) {
+			copy = 0;
+			*op++ = MAX_COPY - 1;
+		}
+	}
+
+	/* left-over as literal copy */
+	ip_bound++;
+	while (ip <= ip_bound) {
+		*op++ = *ip++;
+		copy++;
+		if (copy == MAX_COPY) {
+			copy = 0;
+			*op++ = MAX_COPY - 1;
+		}
+	}
+
+	/* if we have copied something, adjust the copy length */
+	if (copy)
+		*(op - copy - 1) = copy - 1;
+	else
+		op--;
+
+#if FASTLZ_LEVEL == 2
+	/* marker for fastlz2 */
+	*(unsigned char *)output |= (1 << 5);
+#endif
+
+	return op - (unsigned char *)output;
+}
+#endif /* !defined(FASTLZ_COMPRESSOR) */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz.h b/drivers/net/ethernet/chelsio/cxgb4/fastlz.h
new file mode 100644
index 00000000..c3db989b
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz.h
@@ -0,0 +1,88 @@
+/*
+   FastLZ - lightning-fast lossless compression library
+
+   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2017 Chelsio Communications
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+   */
+
+#ifndef FASTLZ_H
+#define FASTLZ_H
+
+#define FASTLZ_VERSION 0x000100
+
+#define FASTLZ_VERSION_MAJOR	 0
+#define FASTLZ_VERSION_MINOR	 0
+#define FASTLZ_VERSION_REVISION  0
+
+#define FASTLZ_VERSION_STRING "0.1.0"
+
+#if defined __cplusplus
+extern "C" {
+#endif
+
+	/**
+	  Compress a block of data in the input buffer and returns the size of
+	  compressed block. The size of input buffer is specified by length. The
+	  minimum input buffer size is 16.
+
+	  The output buffer must be at least 5% larger than the input buffer
+	  and can not be smaller than 66 bytes.
+
+	  If the input is not compressible, the return value might be larger
+	  than length (input buffer size).
+
+	  The input buffer and the output buffer can not overlap.
+	  */
+
+	int fastlz_compress(unsigned char *hash_table, const void *input,
+			    int length, void *output);
+	/**
+	  Compress a block of data in the input buffer and returns the size of
+	  compressed block. The size of input buffer is specified by length. The
+	  minimum input buffer size is 16.
+
+	  The output buffer must be at least 5% larger than the input buffer
+	  and can not be smaller than 66 bytes.
+
+	  If the input is not compressible, the return value might be larger
+	  than length (input buffer size).
+
+	  The input buffer and the output buffer can not overlap.
+
+	  Compression level can be specified in parameter level. At the moment,
+	  only level 1 and level 2 are supported.
+	  Level 1 is the fastest compression and generally useful for short
+	  data.
+	  Level 2 is slightly slower but it gives better compression ratio.
+
+	  Note that the compressed data, regardless of the level, can always be
+	  decompressed using the function fastlz_decompress above.
+	  */
+
+	int fastlz_compress_level(unsigned char *hash_table, int level,
+				  const void *input, int length,
+				  void *output);
+#if defined __cplusplus
+}
+#endif
+#endif /* FASTLZ_H */
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c b/drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c
new file mode 100644
index 00000000..dbf78f7f
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz_api.c
@@ -0,0 +1,176 @@
+/*
+ *  Copyright (C) 2017 Chelsio Communications.  All rights reserved.
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms and conditions of the GNU General Public License,
+ *  version 2, as published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *  more details.
+ *
+ *  The full GNU General Public License is included in this distribution in
+ *  the file called "COPYING".
+ *
+ */
+
+#include "cxgb4.h"
+#include "fastlz.h"
+#include "fastlz_common.h"
+#include "cudbg_if.h"
+#include "cudbg_lib_common.h"
+
+unsigned char sixpack_magic[8] = {137, '6', 'P', 'K', 13, 10, 26, 10};
+
+static int write_to_buf(void *out_buf, u32 out_buf_size, u32 *offset,
+			void *in_buf, u32 in_buf_size)
+{
+	memcpy(((char *)out_buf) + *offset, in_buf, in_buf_size);
+	*offset = *offset + in_buf_size;
+	return 0;
+}
+
+static int write_magic(struct cudbg_buffer *_out_buff)
+{
+	return write_to_buf(_out_buff->data, _out_buff->size,
+			    &_out_buff->offset, sixpack_magic, 8);
+}
+
+static int write_chunk_header(struct cudbg_buffer *_outbuf, int id, int options,
+			      unsigned long size, unsigned long checksum,
+			      unsigned long extra)
+{
+	unsigned char buffer[CUDBG_CHUNK_BUF_LEN];
+
+	buffer[0] = id & 255;
+	buffer[1] = (unsigned char)(id >> 8);
+	buffer[2] = options & 255;
+	buffer[3] = (unsigned char)(options >> 8);
+	buffer[4] = size & 255;
+	buffer[5] = (size >> 8) & 255;
+	buffer[6] = (size >> 16) & 255;
+	buffer[7] = (size >> 24) & 255;
+	buffer[8] = checksum & 255;
+	buffer[9] = (checksum >> 8) & 255;
+	buffer[10] = (checksum >> 16) & 255;
+	buffer[11] = (checksum >> 24) & 255;
+	buffer[12] = extra & 255;
+	buffer[13] = (extra >> 8) & 255;
+	buffer[14] = (extra >> 16) & 255;
+	buffer[15] = (extra >> 24) & 255;
+
+	return write_to_buf(_outbuf->data, _outbuf->size, &_outbuf->offset,
+			    buffer, 16);
+}
+
+int cudbg_write_compression_hdr(struct cudbg_init *pdbg_init,
+				struct cudbg_buffer *pin_buff,
+				struct cudbg_buffer *pout_buff)
+{
+	struct cudbg_buffer temp_buff = { 0 };
+	unsigned long fsize = pin_buff->size;
+	char *shown_name = "abc";
+	unsigned long checksum;
+	unsigned char *buffer;
+	int rc;
+
+	cudbg_get_compress_buff(pdbg_init, pin_buff, &temp_buff);
+	buffer = (unsigned char *)temp_buff.data;
+
+	rc = write_magic(pout_buff);
+	if (rc)
+		return rc;
+
+	/* chunk for File Entry */
+	buffer[0] = fsize & 255;
+	buffer[1] = (fsize >> 8) & 255;
+	buffer[2] = (fsize >> 16) & 255;
+	buffer[3] = (fsize >> 24) & 255;
+	buffer[4] = 0;
+	buffer[5] = 0;
+	buffer[6] = 0;
+	buffer[7] = 0;
+	buffer[8] = (strlen(shown_name) + 1) & 255;
+	buffer[9] = (unsigned char)((strlen(shown_name) + 1) >> 8);
+	checksum = 1L;
+	checksum = update_adler32(checksum, buffer, 10);
+	checksum = update_adler32(checksum, shown_name,
+				  (int)strlen(shown_name) + 1);
+
+	rc = write_chunk_header(pout_buff, 1, 0,
+				10 + (unsigned long)strlen(shown_name)+ 1,
+				checksum, 0);
+	if (rc)
+		return rc;
+
+	rc = write_to_buf(pout_buff->data, pout_buff->size,
+			  &pout_buff->offset, buffer, 10);
+	if (rc)
+		return rc;
+
+	rc = write_to_buf(pout_buff->data, pout_buff->size,
+			   &pout_buff->offset, shown_name,
+			   (u32)strlen(shown_name) + 1);
+	if (rc)
+		return rc;
+
+	return rc;
+}
+
+int cudbg_compress_buff(struct cudbg_init *pdbg_init,
+			struct cudbg_buffer *pin_buff,
+			struct cudbg_buffer *pout_buff)
+{
+	struct cudbg_buffer temp_buff = { 0 };
+	int chunk_size, level = 2, rc = 0;
+	int compress_method = 1;
+	unsigned int bytes_read;
+	unsigned long checksum;
+	unsigned char *result;
+
+	cudbg_get_compress_buff(pdbg_init, pin_buff, &temp_buff);
+	result = (unsigned char *)temp_buff.data;
+
+	bytes_read = pin_buff->size;
+	if (bytes_read < 32)
+		compress_method = 0;
+
+	switch (compress_method) {
+	case 1:
+		chunk_size = fastlz_compress_level(pdbg_init->hash_table,
+						   level,
+						   pin_buff->data,
+						   bytes_read, result);
+		checksum = update_adler32(1L, result, chunk_size);
+		rc = write_chunk_header(pout_buff, 17, 1, chunk_size, checksum,
+					bytes_read);
+		if (rc)
+			return rc;
+
+		rc = write_to_buf(pout_buff->data, pout_buff->size,
+				  &pout_buff->offset, result, chunk_size);
+		if (rc)
+			return rc;
+		break;
+
+		/* uncompressed, also fallback method */
+	case 0:
+	default:
+		memcpy(result, pin_buff->data, bytes_read);
+		checksum = update_adler32(1L, result, bytes_read);
+		rc = write_chunk_header(pout_buff, 17, 0, bytes_read, checksum,
+					bytes_read);
+		if (rc)
+			return rc;
+
+		rc = write_to_buf(pout_buff->data, pout_buff->size,
+				  &pout_buff->offset, result,
+				  bytes_read);
+		if (rc)
+			return rc;
+		break;
+	}
+
+	return rc;
+}
diff --git a/drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h b/drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h
new file mode 100644
index 00000000..19e0e45a
--- /dev/null
+++ b/drivers/net/ethernet/chelsio/cxgb4/fastlz_common.h
@@ -0,0 +1,134 @@
+/*
+   FastLZ - lightning-fast lossless compression library
+
+   Copyright (C) 2007 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2006 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2005 Ariya Hidayat (ariya@kde.org)
+   Copyright (C) 2017 Chelsio Communications
+
+   Permission is hereby granted, free of charge, to any person obtaining a copy
+   of this software and associated documentation files (the "Software"), to deal
+   in the Software without restriction, including without limitation the rights
+   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+   copies of the Software, and to permit persons to whom the Software is
+   furnished to do so, subject to the following conditions:
+
+   The above copyright notice and this permission notice shall be included in
+   all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+   THE SOFTWARE.
+   */
+
+#ifndef __FASTLZ_COMMON_H__
+#define __FASTLZ_COMMON_H__
+
+#define FASTLZ_HASH_LOG  13
+#define FASTLZ_HASH_SIZE (1 << FASTLZ_HASH_LOG)
+#define FASTLZ_HASH_MASK  (FASTLZ_HASH_SIZE - 1)
+
+/*
+ * Always check for bound when decompressing.
+ * Generally it is best to leave it defined.
+ */
+#define FASTLZ_SAFE
+
+/*
+ * Give hints to the compiler for branch prediction optimization.
+ */
+#define FASTLZ_EXPECT_CONDITIONAL(c)	(__builtin_expect((c), 1))
+#define FASTLZ_UNEXPECT_CONDITIONAL(c)	(__builtin_expect((c), 0))
+
+/*
+ * Use inlined functions for supported systems.
+ */
+#define FASTLZ_INLINE inline
+
+/*
+ * Prevent accessing more than 8-bit at once, except on x86 architectures.
+ */
+#if !defined(FASTLZ_STRICT_ALIGN)
+#define FASTLZ_STRICT_ALIGN
+#if defined(__i386__) || defined(__386)  /* GNU C, Sun Studio */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(__i486__) || defined(__i586__) || defined(__i686__) /* GNU C */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(_M_IX86) /* Intel, MSVC */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(__386)
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(_X86_) /* MinGW */
+#undef FASTLZ_STRICT_ALIGN
+#elif defined(__I86__) /* Digital Mars */
+#undef FASTLZ_STRICT_ALIGN
+#endif
+#endif
+
+/*
+ * FIXME: use preprocessor magic to set this on different platforms!
+ */
+
+#define MAX_COPY       32
+#define MAX_LEN       264  /* 256 + 8 */
+#define MAX_DISTANCE 8192
+
+#if !defined(FASTLZ_STRICT_ALIGN)
+#define FASTLZ_READU16(p) (*((const unsigned short *)(p)))
+#else
+#define FASTLZ_READU16(p) ((p)[0] | (p)[1]<<8)
+#endif
+
+#define HASH_FUNCTION(v, p) {\
+				v = FASTLZ_READU16(p);\
+				v ^= FASTLZ_READU16(p + 1)^\
+				     (v>>(16 - FASTLZ_HASH_LOG));\
+				v &= FASTLZ_HASH_MASK;\
+			    }
+
+extern unsigned char sixpack_magic[8];
+
+#define CUDBG_BLOCK_SIZE      (63*1024)
+#define CUDBG_CHUNK_BUF_LEN   16
+#define CUDBG_MIN_COMPR_LEN   32	/*min data length for applying compression*/
+
+/* for Adler-32 checksum algorithm, see RFC 1950 Section 8.2 */
+
+#define ADLER32_BASE 65521
+
+static inline unsigned long update_adler32(unsigned long checksum,
+					   const void *buf, int len)
+{
+	const unsigned char *ptr = (const unsigned char *)buf;
+	unsigned long s1 = checksum & 0xffff;
+	unsigned long s2 = (checksum >> 16) & 0xffff;
+
+	while (len > 0) {
+		unsigned k = len < 5552 ? len : 5552;
+		len -= k;
+
+		while (k >= 8) {
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			s1 += *ptr++; s2 += s1;
+			k -= 8;
+		}
+
+		while (k-- > 0) {
+			s1 += *ptr++; s2 += s1;
+		}
+		s1 = s1 % ADLER32_BASE;
+		s2 = s2 % ADLER32_BASE;
+	}
+	return (s2 << 16) + s1;
+}
+#endif /* __FASTLZ_COMMON_H__ */
-- 
2.14.1

